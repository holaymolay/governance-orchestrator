name: Spec Compiler Enforcement

on:
  push:
    branches:
      - main
      - master
  pull_request:
    paths:
      - "specs/**"
      - ".github/workflows/spec-compiler-enforcement.yml"

jobs:
  spec-compiler-enforcement:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install spec-generation-framework (RULE 2)
        run: |
          set -euo pipefail
          if ! python -m pip install --upgrade git+https://github.com/holaymolay/spec-generation-framework.git; then
            echo "RULE 2: spec-generation-framework is required for spec validation; install failed."
            exit 1
          fi
          if ! command -v spec-compile >/dev/null 2>&1; then
            echo "RULE 2: spec-generation-framework is required for spec validation; spec-compile not found after install."
            exit 1
          fi
          SPEC_VERSION="$(spec-compile --version 2>/dev/null || true)"
          if [ -z "${SPEC_VERSION}" ]; then
            echo "RULE 2: spec-generation-framework is required for spec validation; cannot determine compiler version."
            exit 1
          fi
          echo "COMPILER_VERSION=${SPEC_VERSION}" >> "$GITHUB_ENV"

      - name: Validate spec provenance and drift (RULES 1 & 4)
        run: |
          set -euo pipefail
          python - <<'PY'
import os
import re
from pathlib import Path

root = Path("specs")
compiler_version = os.environ.get("COMPILER_VERSION", "").strip()
semver_re = re.compile(r"^[0-9]+\.[0-9]+\.[0-9]+([+-][0-9A-Za-z\.-]+)?$")

def fail(msg: str) -> None:
    print(msg)
    raise SystemExit(1)

if not compiler_version:
    fail("RULE 2: spec-generation-framework version is unknown; install step did not set COMPILER_VERSION.")

if not root.exists():
    print("No specs/ directory present; skipping provenance checks.")
    raise SystemExit(0)

violations = []
for path in sorted(root.rglob("*")):
    if path.is_dir():
        continue
    text = path.read_text(encoding="utf-8")
    lines = text.splitlines()
    if len(lines) < 3 or lines[0].strip() != "---":
        violations.append((path, "RULE 1: missing frontmatter delimiter '---' at start of spec. Add required metadata."))
        continue
    try:
        end_idx = lines[1:].index("---") + 1
    except ValueError:
        violations.append((path, "RULE 1: missing closing frontmatter delimiter '---'. Add required metadata block."))
        continue
    frontmatter_lines = lines[1:end_idx]
    data = {}
    for line in frontmatter_lines:
        if ":" not in line:
            continue
        key, val = line.split(":", 1)
        data[key.strip()] = val.strip()
    required = ["spec_id", "compiler_name", "compiler_version", "compilation_timestamp"]
    for key in required:
        if key not in data or not data[key]:
            violations.append((path, f"RULE 1: {key} missing in frontmatter. Add `{key}: ...`"))
    if data.get("compiler_name") and data.get("compiler_name") != "spec-generation-framework":
        violations.append((path, "RULE 1: compiler_name must be 'spec-generation-framework'."))
    cv = data.get("compiler_version", "")
    if cv and not semver_re.match(cv):
        violations.append((path, "RULE 1: compiler_version must be semver (e.g., 1.2.3)."))
    if cv and compiler_version and cv != compiler_version:
        violations.append((path, f"RULE 4: compiler_version '{cv}' does not match installed '{compiler_version}'. Re-run spec-generation-framework and update frontmatter."))

if violations:
    for path, msg in violations:
        print(f"{msg} File: {path}")
    raise SystemExit(1)
else:
    print("Spec provenance and compiler drift checks passed.")
PY

      - name: Run compiler validation (RULE 2)
        run: |
          set -euo pipefail
          if ! command -v spec-compile >/dev/null 2>&1; then
            echo "RULE 2: spec-generation-framework is required; spec-compile not found."
            exit 1
          fi
          if ! spec-compile validate; then
            echo "RULE 2: spec-compile validate failed. Fix the reported spec errors."
            exit 1
          fi

      - name: Enforce Codex prompt consumption (RULE 3)
        run: |
          set -euo pipefail
          python - <<'PY'
import re
from pathlib import Path

workflows = list(Path(".github/workflows").glob("*.yml")) + list(Path(".github/workflows").glob("*.yaml"))
violations = []

for wf in workflows:
    text = wf.read_text(encoding="utf-8")
    has_codex = re.search(r"codex", text, re.IGNORECASE) is not None
    if not has_codex:
        continue
    if "synthesis/codex.prompt.md" not in text:
        violations.append((wf, "RULE 3: Codex step found without referencing synthesis/codex.prompt.md"))

prompt_path = Path("synthesis/codex.prompt.md")
if any("codex" in wf.read_text().lower() for wf in workflows):
    if not prompt_path.exists():
        violations.append((prompt_path, "RULE 3: synthesis/codex.prompt.md is required when Codex steps exist. Add prompt with provenance metadata."))
    else:
        content = prompt_path.read_text(encoding="utf-8")
        required = ["spec_id:", "compiler_name:", "compiler_version:", "compilation_timestamp:"]
        missing = [r for r in required if r not in content]
        if missing:
            violations.append((prompt_path, f"RULE 3: prompt missing metadata fields: {', '.join(missing)}"))

if violations:
    for path, msg in violations:
        print(f"{msg} File: {path}")
    raise SystemExit(1)
else:
    print("Codex prompt consumption checks passed.")
PY
